从操作系统到线程与进程
=================================
&#8195;&#8195;&#8195;摘自阮一峰的博客，《进程与线程的一个简单解释》下的评论。


&#8195;&#8195;&#8195;进程和线程简单而基本靠谱的定义如下
  
&#8195;&#8195;&#8195;1. 进程：程序的一次执行  

&#8195;&#8195;&#8195;2. 线程：CPU的基本调度单位  

&#8195;&#8195;&#8195;这两个概念虽然过于简单，但是完全可以为理解OS/线程/进程打下坚实的基础，我认为关于进程/线程的探讨，无论采用何种方式，都必须以这两句话为落脚点，才算靠谱。



&#8195;&#8195;&#8195;1、在单核计算机里，有一个资源是无法被多个程序并行使用的：cpu。

&#8195;&#8195;&#8195;没有操作系统的情况下，一个程序一直独占着全都cpu。

&#8195;&#8195;&#8195;如果要有两个任务来共享同一个CPU，程序员就需要仔细地为程序安排好运行计划--某时刻cpu和由程序A来独享，下一时刻cpu由程序B来独享

&#8195;&#8195;&#8195;而这种安排计划后来成为OS的核心组件，被单独名命为“scheduler”，即“调度器”，它关心的只是怎样把单个cpu的运行拆分成一段一段的“运行片”，轮流分给不同的程序去使用，而在宏观上，因为分配切换的速度极快，就制造出多程序并行在一个cpu上的假象。

&#8195;&#8195;&#8195;2、在单核计算机里，有一个资源可以被多个程序共用，然而会引出麻烦：内存。

&#8195;&#8195;&#8195;在一个只有调度器，没有内存管理组件的操作系统上，程序员需要手工为每个程序安排运行的空间 -- 程序A使用物理地址0x00-0xff,程序B使用物理地址0x100-0x1ff，等等。

&#8195;&#8195;&#8195;然而这样做有个很大的问题：每个程序都要协调商量好怎样使用同一个内存上的不同空间，软件系统和硬件系统千差万别，使这种定制的方案没有可行性。  
为了解决这个麻烦，计算机系统引入了“虚拟地址”的概念，从三方面入手来做：

&#8195;&#8195;&#8195;2.1、硬件上，CPU增加了一个专门的模块叫MMU，负责转换虚拟地址和物理地址。  

&#8195;&#8195;&#8195;2.2、操作系统上，操作系统增加了另一个核心组件：memory management，即内存管理模块，它管理物理内存、虚拟内存相关的一系列事务。  

&#8195;&#8195;&#8195;2.3、应用程序上，发明了一个叫做【进程】的模型，（注意）每个进程都用【完全一样的】虚拟地址空间，然而经由操作系统和硬件MMU协作，映射到不同的物理地址空间上。不同的【进程】，都有各自独立的物理内存空间，不用一些特殊手段，是无法访问别的进程的物理内存的。

&#8195;&#8195;&#8195;3、现在，不同的应用程序，可以不关心底层的物理内存分配，也不关心CPU的协调共享了。然而还有一个问题存在：有一些程序，想要共享CPU，【并且还要共享同样的物理内存】，这时候，一个叫【线程】的模型就出现了，它们被包裹在进程里面，在调度器的管理下共享CPu，拥有同样的虚拟地址空间，同时也共享同一个物理地址空间，然而，它们无法越过包裹自己的进程，去访问别一个进程的物理地址空间。

&#8195;&#8195;&#8195;4、进程之间怎样共享同一个物理地址空间呢？不同的系统方法各异，符合posix规范的操作系统都提供了一个接口，叫mmap，可以把一个物理地址空间映射到不同的进程中，由不同的进程来共享。

&#8195;&#8195;&#8195;5、PS：在有的操作系统里，进程不是调度单位（即不能被调度器使用），线程是最基本的调度单位，调度器只调度线程，不调度进程，比如VxWorks。

