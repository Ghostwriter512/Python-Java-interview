从情侣牵手分手到TCP三次握手四次挥手
=================================




## 为何恰好是三次握手？
&#8195;&#8195;&#8195;一对异地的男女，只能通过书信来沟通。临走前，双方并未表明心意，如今小伙子在远方谋生，姑娘在家乡生活，眼看两人渐行渐远，心爱的姑娘已经到了该嫁人的年龄，小伙子坐不住了，下定决心给姑娘写信，表明心意。

&#8195;&#8195;&#8195;第一阶段：小伙子写好书信，放进邮筒，通篇没有一句喜欢，却字字都是我爱你。

&#8195;&#8195;&#8195;第二阶段：姑娘收到书信，无比欢喜，回信一封，通篇没有一个爱字，却句句都是我愿意。

&#8195;&#8195;&#8195;第三阶段：小伙子收到书信，终于确认对方对自己也心存爱意，接下来便可以书信往来交流感情了。

&#8195;&#8195;&#8195;

&#8195;&#8195;&#8195;

&#8195;&#8195;&#8195;那么对于数据传输的双方而言，要想实现正常的数据传输，就必须要考虑四个问题：

&#8195;&#8195;&#8195;1.客户端的发送数据能力是否正常。

&#8195;&#8195;&#8195;2.客户端的接收数据能力是否正常。

&#8195;&#8195;&#8195;3.服务器的发送数据能力是否正常。

&#8195;&#8195;&#8195;4.服务器的接收数据能力是否正常。

&#8195;&#8195;&#8195;为了确认以上四个问题，我作为客户端向服务器发送数据，服务器收到了，证明我的发送能力和服务器的接收能力是正常的（但是此时我并不知道自己发送的数据是否到了该去的地方，因此需要服务器的回信来确认），服务器向我发送数据，我收到了，证明我，也就是客户端的发送能力和接受能力，以及服务器的发送能力是正常的（但是此时服务器不知道自己发送的数据是否到了该去的地方，因此需要客户端回信来确认），我再次向服务器发送数据，服务器收到，证明以上四个能力正常，可以开始正式的数据传输了。


## 三次握手的详细过程是什么？
![enter image description here](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzcvMTZmN2UwM2IxZWE1MDdlOA?x-oss-process=image/format,png)

&#8195;&#8195;&#8195;首先对几个字段进行解释：

&#8195;&#8195;&#8195;（1）序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。

&#8195;&#8195;&#8195;（2）确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。

&#8195;&#8195;&#8195;（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：

-   ACK：确认序号有效。
-   FIN：释放一个连接。
-   PSH：接收方应该尽快将这个报文交给应用层。
-   RST：重置连接。
-   SYN：发起一个新连接。
-   URG：紧急指针（urgent pointer）有效。

&#8195;&#8195;&#8195;第一次握手：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。

&#8195;&#8195;&#8195;第二次握手：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。

&#8195;&#8195;&#8195;第三次握手：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。

## 为何恰好是四次挥手？
&#8195;&#8195;&#8195;如果说握手是两个人互相试探并最终在一起的过程，那么挥手就是一个非常典型的分手过程。

&#8195;&#8195;&#8195;假如我是服务器，而姑娘是客户端。那么我和这个姑娘的分手流程，可以分为四个阶段。

&#8195;&#8195;&#8195;第一阶段：姑娘对我提出分手，我惊讶，原地不知所措。

&#8195;&#8195;&#8195;第二阶段：我回过神，对姑娘说，再等等吧，我可以做得更好。

&#8195;&#8195;&#8195;第三阶段：我黔驴技穷，挽回不了姑娘的心，只好对她说，好吧，分手吧。

&#8195;&#8195;&#8195;第四阶段：姑娘对我说：嗯，那就分手吧。 我收到消息，彻底死心，删除好友断开连接，而姑娘其实并不想完全分手，因而等了2MSL(最长报文段寿命的2倍时长)，没有回信，则彻底分手。


## 四次挥手的详细过程是什么？

![enter image description here](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzcvMTZmN2UwM2IyMWEwN2YwYw?x-oss-process=image/format,png)
&#8195;&#8195;&#8195;比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。

&#8195;&#8195;&#8195;第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。

&#8195;&#8195;&#8195;第二次挥手：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。

&#8195;&#8195;&#8195;第三次挥手：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。

&#8195;&#8195;&#8195;第四次挥手：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。



## 为什么TCP连接的时候是3次？2次不可以吗？
&#8195;&#8195;&#8195;一言以蔽之：因为姑娘和小伙子没有上帝视角，只能通过单线书信沟通知道对方是否准备好了。

&#8195;&#8195;&#8195;因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。

&#8195;&#8195;&#8195;如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。

##  为什么TCP连接的时候是3次，关闭的时候却是4次？
&#8195;&#8195;&#8195;一言以蔽之：因为天长地久有时尽，此情绵绵无绝期，要等爱意释放完全，彻底死心才能断开。

&#8195;&#8195;&#8195;因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。

##  为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？
&#8195;&#8195;&#8195;一言以蔽之：因为分手也要体面，等等对方看看有没有没说完的话。

&#8195;&#8195;&#8195;这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。
## 如果已经建立了连接，但是客户端突然出现故障了怎么办？
&#8195;&#8195;&#8195;一言以蔽之：出现了问题，那么就再多尝试几次，心中有杆秤，超过了承受底线，就断开吧。

&#8195;&#8195;&#8195;TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

