
以初学者的角度看互联网的五层模型。
==============
    今天阅读了一些关于互联网的文章，特意写下这篇文章作为记录。
&#8195;&#8195;&#8195;在对模型进行阐释之前，需要首先了解一个概念：协议。所谓协议，就是为了实现某些功能而需要大家遵守的共同的规则。互联网世界有许许多多的条条框框，在这些条条框框中才可以正常运行，可谓是“带着镣铐的舞蹈”，这些条条框框便是协议了。

&#8195;&#8195;&#8195;如果将互联网分为五层，那么可以将其从上至下分为：
![enter image description here](https://github.com/Ghostwriter512/Python-Java-interview/blob/master/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/1.png)
&#8195;&#8195;&#8195;其中应用层距离用户最近，实体层最远。

## 实体层

&#8195;&#8195;&#8195;实体层，也叫物理层，指的是把电脑连接起来的物理手段，比如光纤和电缆。它的作用是传送0和1的电信号。现在可以设想我们是农民，收获了一大批的小麦和水稻，对应着电信号的0和1，我们要把这些小麦和水稻通过物理途径（管道）传输出去，肯定不能一股脑的全塞到管道里去，不然管道那头的人会很头大。再比如，金牌厨师大司马经典贼眉鼠眼：

![enter image description here](https://github.com/Ghostwriter512/Python-Java-interview/blob/master/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/zmsy1.png)
&#8195;&#8195;&#8195;如果只看眉眼，很难判断这人到底是个啥情况，但是通过马老师的光速挠头，我们可以根据个人经验判断出这波应该是被秀了。

![enter image description here](https://github.com/Ghostwriter512/Python-Java-interview/blob/master/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/zmsy2.png)

&#8195;&#8195;&#8195;这波啊，这波是没想到自己会死。

![enter image description here](https://github.com/Ghostwriter512/Python-Java-interview/blob/master/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/zmsy3.png)

&#8195;&#8195;&#8195;这波应该是发病了。

&#8195;&#8195;&#8195;计算机也是这样，你发来一大堆的信号，我根本搞不懂断点在哪，就像一堆文字没有标点符号一样，让人头晕，所以就必须要有一个包装过程，把水稻和小麦安置好，把表情和动作管理好，这样才能让其它的计算机明白我们的意思，才能实现通信。
&#8195;&#8195;&#8195;你现在应该看到了两层，却只把我想成了第一层，实际上，我有五层。
## 链接层

&#8195;&#8195;&#8195;单纯的0和1没有意义，或者说有意义但是别人看不懂，我们就必须规定解读方式：多少个电信号算一组？每个信号位有何意义？这就是链接层的功能，它在实体层的上方，确定了0和1的分组方式。具体该怎么分呢？人们规定了一个叫做“以太网”的协议。以太网规定：一组电信号构成一个数据包，叫做“帧”，。每一帧分成两个部分：标头（Head）和数据（Data）。

![enter image description here](https://github.com/Ghostwriter512/Python-Java-interview/blob/master/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/2.png)

&#8195;&#8195;&#8195;Head包含数据包的一些说明项，比如发送者，接受者，数据类型等。“Data”是数据包的具体内容。Head的长度固定为18字节，Data的长度最短为46字节，最长为1500字节。因此，整个“帧”最短为64字节，最长为1518字节，如果数据很长，就需要分为多个“帧”进行发送。
&#8195;&#8195;&#8195;这个过程可以想象成把小麦和水稻按照规则打包好了，装在袋子里，要从深圳寄给远在河南的家人，就需要在袋子上贴张快递单（Head），上面写着发送者，接受者，物品类型（数据类型）。
&#8195;&#8195;&#8195;上面提到，标头包含着发送者和接收者的信息，那么发送者和接收者是如何标识呢？以太网规定，连入网络的所有设备，都必须具有"网卡"接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。
&#8195;&#8195;&#8195;每一块网卡出厂时，都会有一个独一无二的MAC地址。那么有了接收方，有了发送方，便可以传输信息了。一块网卡可以通过ARP协议得知另一块网卡的MAC地址。
&#8195;&#8195;&#8195;如今已经有了MAC地址，发送过程如下：

![enter image description here](https://github.com/Ghostwriter512/Python-Java-interview/blob/master/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/3.png)

&#8195;&#8195;&#8195;上图中，1号计算机向2号计算机发送一个数据包，同一个自网络内的3号，4号，5号计算机都会收到这个包，它们读取这个包的Head（看一眼快递单是不是给我的），如果确定是给自己的，就接受，否则丢弃。这种发送方式称为“广播”。
&#8195;&#8195;&#8195;大家都知道，在小村子里，广播是很有用的，村长在广播里一喊，全村的狗都开始叫了，不对，全村的人都听到了。
&#8195;&#8195;&#8195;可是如果村长在广东出差，想告诉河南的村民快下雨了赶紧收衣服，又该怎么办呢？理论上，只要这村长嗓门够大，别说河南了，黑龙江的村民都听得到。可是问题来了，村长这一嗓子吼下去，河南的村民能听到，那也就意味着广西江苏上海的村民也都听得到，广东离香港那么近，万一一嗓子把香港的某些废青吓死了，街上扔那么一大堆垃圾也不环保啊。所以为了环保，就限制这广播，只能在村里用，也就是广播只能在子网络内用。因此，就要找到一种方法，区分哪些MAC地址属于同一个子网络，哪些不属于同一个子网络。如果是同一个子网络，就广播，不是，就采用“路由”的方式发送。因此，网络层诞生了。
## 网络层
&#8195;&#8195;&#8195;网络层的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络，这套地址就叫做网络地址，简称网址。

&#8195;&#8195;&#8195;于是，网络层出现以后，使得每台计算机都有了两种地址，一种是MAC地址，另一种是网络地址。两种地址间没有任何联系，MAC地址是绑在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。

&#8195;&#8195;&#8195;网络地址可以帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络的目标网卡，因此逻辑上可以推断，必定是先处理网络地址，再处理MAC地址。

&#8195;&#8195;&#8195;这里就需要IP协议来帮忙了，可以从IP判断两台计算机是否属于同一个子网络。

&#8195;&#8195;&#8195;加入了IP协议后，数据包自然而然也要进行相应的修改：

![enter image description here](https://github.com/Ghostwriter512/Python-Java-interview/blob/master/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/4.png)

&#8195;&#8195;&#8195;加入了IP协议后，已经可以实现从主机到主机的通信，可是我们在日常使用中，往往是多个应用都需要用到网络服务，比如一边聊天一边听音乐一边玩游戏，当一个数据包发来，要如何去判断这个数据包是属于游戏的，还是聊天的呢？
## 传输层

&#8195;&#8195;&#8195;我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做"端口"（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。

&#8195;&#8195;&#8195;"端口"是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。

&#8195;&#8195;&#8195;"传输层"的功能，就是建立"端口到端口"的通信。相比之下，"网络层"的功能是建立"主机到主机"的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做"套接字"（socket）。有了它，就可以进行网络应用程序开发了。

&#8195;&#8195;&#8195;现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。

![enter image description here](https://github.com/Ghostwriter512/Python-Java-interview/blob/master/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/5.png)

&#8195;&#8195;&#8195;UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。

&#8195;&#8195;&#8195;为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。

&#8195;&#8195;&#8195;因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。

&#8195;&#8195;&#8195;TCP数据包和UDP数据包一样，都是内嵌在IP数据包的"数据"部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。
## 应用层

&#8195;&#8195;&#8195;应用程序收到"传输层"的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。

&#8195;&#8195;&#8195;"应用层"的作用，就是规定应用程序的数据格式。

&#8195;&#8195;&#8195;举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了"应用层"。

&#8195;&#8195;&#8195;这是最高的一层，直接面对用户。它的数据就放在TCP数据包的"数据"部分。因此，现在的以太网的数据包就变成下面这样。

![enter image description here](https://github.com/Ghostwriter512/Python-Java-interview/blob/master/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/6.png)
