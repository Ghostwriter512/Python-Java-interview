为什么重写equals还要重写hashcode？
==============
    
&#8195;&#8195;&#8195;要挖掘这个问题背后的原因，需要从三个方面考虑。
## equals是什么？

&#8195;&#8195;&#8195;equals方法：用来判断两个对象是否为同一个对象。

&#8195;&#8195;&#8195;代码如下：
`public boolean equals(Object obj){  return (this == obj); }`

&#8195;&#8195;&#8195;可以看到底层用到了==来实现，也就是说通过equals方法来判断两个对象是否为同一个对象，本质上是对两个对象的内存地址进行比较，如果相同，则认为是同一个对象，返回true，如果不同，则认为不是同一个对象，返回false。

## 为什么要重写equals？
&#8195;&#8195;&#8195;重写和重载是不同的，重写是面向对象编程中多态的实际体现，是“青出于蓝而胜于蓝”。重载是为了让函数适应更多的情况，是追求“silver bullet”的一种努力。

&#8195;&#8195;&#8195;在第一部分中，我们知道了equals是通过内存地址来判断两个对象是否为同一个对象。这种方法是有缺陷的，因为在实际应用中，我们认为两个对象即使不是指向的同一块内存，只要这两个对象的各个字段属性值都相同，那么就认为这两个对象是同一个对象，这才是符合人的思考过程的。所以我们需要对equals进行重写。

## hashcode是什么？
&#8195;&#8195;&#8195;hashCode()是一个native方法，哈希值的计算利用的是内存地址，因此我们可以简略地写成 

    hashcode = f(内存地址)
    
 &#8195;&#8195;&#8195;即hashcode就是通过对内存地址进行特殊计算得到的值。因此我们暂且可以认为，可以用hashcode来判断两个对象是否相同。
 
## hashcode是完美的吗？

&#8195;&#8195;&#8195;hashcode既然是通过对内存地址进行特殊计算得到的值，那么不可避免的，就会遇到两个对象内存地址并不相同但hashcode相同的情况。这种情况称为哈希冲突。由于哈希表具有优秀的查询性能，而equals方法性能较差，因此hashcode才和equals方法产生了联系，我们可以把hashcode和equals配合使用，达到事半功倍的效果。就像是一个盲人遇到了一个聋子，你做我的眼，我做你的耳朵。

## # equals方法和hashCode方法两者有什么关系？
&#8195;&#8195;&#8195;如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定相同。

&#8195;&#8195;&#8195;如果两个对象不同（即用equals比较返回false），那么它们的hashCode值可能相同也可能不同

&#8195;&#8195;&#8195;如果两个对象的hashCode相同（存在哈希冲突），那么它们可能相同也可能不同(即equals比较可能是false也可能是true)

&#8195;&#8195;&#8195;如果两个对象的hashCode不同，那么他们肯定不同(即用equals比较返回false)

## 为什么重写equals就一定要重写hashCode方法？
&#8195;&#8195;&#8195;对于对象集合的判重，如果一个集合含有10000个对象实例，仅仅使用equals()方法的话，那么对于一个对象判重就需要比较10000次，随着集合规模的增大，时间开销是很大的。但是同时使用哈希表的话，就能快速定位到对象的大概存储位置，并且在定位到大概存储位置后，后续比较过程中，如果两个对象的hashCode不相同，也不再需要调用equals（）方法，从而大大减少了equals()比较次数。

&#8195;&#8195;&#8195;所以从程序实现原理上来讲的话，既需要equals()方法，也需要hashCode()方法。那么既然重写了equals（），那么也要重写hashCode()方法，以保证两者之间的配合关系。

## 如果重写equals之后没有重写hashCode，会发生什么？
&#8195;&#8195;&#8195;字段属性值完全相同的两个对象可能会因为hashCode不同，所以在hashmap中的table数组的下标不同，从而这两个对象就会同时存在于集合中，这种集合是不符合要求的。

